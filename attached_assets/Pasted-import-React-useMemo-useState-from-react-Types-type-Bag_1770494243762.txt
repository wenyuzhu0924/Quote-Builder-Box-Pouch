import React, { useMemo, useState } from "react";

// --- Types ---

type BagType =
  | "standup"
  | "threeSide"
  | "centerSeal"
  | "gusset"
  | "eightSide"
  | "taperBottom"
  | "flatBottom"
  | "taperShape"
  | "threeSideShape"
  | "rollFilm"; // 新增：卷膜

type MaterialKey =
  | "PET"
  | "VMPET"
  | "BOPP"
  | "MOPP"
  | "MPET"
  | "CPP"
  | "VMCPP"
  | "PE"
  | "BOPA"
  | "Kraft"
  | "WhiteKraft"
  | "CottonPaper"
  | "AL"
  | "GoldSandFilm" // 新增 金砂膜/拉丝膜
  | "TouchOPP"     // ✅ 新增：触感膜OPP
  | "PLA"          // ✅ 新增：PLA可降解材料
  | "KPA"
  | "AluminaPETComposite"  // 氧化铝PET(复合级)
  | "AluminaPETPrint"      // 氧化铝PET(印刷级)
  | "KPET"
  | "KOP"
  | "LaserPETAl"          // 镭射PET铝
  | "Custom";

type Layer = {
  id: string;
  material: MaterialKey;
  thicknessUm: number | "";   // ✅ 允许清空
  density: number | "";       // ✅ 允许清空
  pricePerKg: number | "";    // ✅ 允许清空
  splice?: {
    enabled: boolean;
    windowWidthMm: number | "";  // ✅ 允许清空
    windowMaterial: MaterialKey;
    windowThicknessUm: number | ""; // 新增：窗口膜厚度（um）
  };
};

type LaminationStep = {
  id: string;
  process: "dry" | "dry_retort" | "solventless";
};

// --- Reference tables from spec ---
const MATERIAL_PRESETS: Record<
  MaterialKey,
  { density?: number; defaultThickness?: number; pricePerKg?: number; label: string }
> = {
  PET: { density: 1.4, defaultThickness: 12, pricePerKg: 8, label: "PET" },
  VMPET: { density: 1.4, defaultThickness: 12, pricePerKg: 9, label: "VMPET" },
  BOPP: { density: 0.91, defaultThickness: 23, pricePerKg: 8.8, label: "BOPP" },
  MOPP: { density: 0.86, defaultThickness: 19, pricePerKg: 9, label: "哑光OPP" },
  MPET: { density: 1.4, defaultThickness: 15, pricePerKg: 12.5, label: "哑光PET" },
  CPP: { density: 0.91, defaultThickness: 40, pricePerKg: 9, label: "CPP" },
  VMCPP: { density: 0.91, defaultThickness: 25, pricePerKg: 11, label: "VMCPP" },
  PE: { density: 0.92, defaultThickness: 70, pricePerKg: 9.5, label: "PE (LDPE)" },
  BOPA: { density: 1.16, defaultThickness: 15, pricePerKg: 17, label: "BOPA" },
  Kraft: { density: 0, defaultThickness: 70, pricePerKg: 7, label: "牛皮纸 (gsm)" },
  WhiteKraft: { density: 0, defaultThickness: 70, pricePerKg: 8, label: "白牛皮纸 (gsm)" },
  CottonPaper: { density: 0, defaultThickness: 19, pricePerKg: 11, label: "棉纸 (gsm)" },
  AL: { density: 2.7, defaultThickness: 7, pricePerKg: 26, label: "AL (纯铝箔)" },
  GoldSandFilm: { density: 0.56, defaultThickness: 55, pricePerKg: 11.5, label: "金砂膜/拉丝膜" },
  // ✅ 新增：触感膜OPP 【1.8丝=18μm、密度0.81、42元/kg】
  TouchOPP: { density: 0.81, defaultThickness: 18, pricePerKg: 42, label: "触感膜OPP" },
  // ✅ 新增：PLA材料 【默认2.5丝=25μm，可手动改1.5丝=15μm、密度1.26、48元/kg】
  PLA: { density: 1.26, defaultThickness: 25, pricePerKg: 48, label: "PLA可降解材料" },
  KPA: { density: 1.2, defaultThickness: 1.7, pricePerKg: 21, label: "KPA" },
  AluminaPETComposite: { density: 1.4, defaultThickness: 1.2, pricePerKg: 12, label: "氧化铝PET(复合级)" },
  AluminaPETPrint: { density: 1.4, defaultThickness: 1.2, pricePerKg: 20, label: "氧化铝PET(印刷级)" },
  KPET: { density: 1.4, defaultThickness: 1.4, pricePerKg: 13, label: "KPET" },
  KOP: { density: 0.99, defaultThickness: 2.1, pricePerKg: 14.5, label: "KOP" },
  LaserPETAl: { density: 1.4, defaultThickness: 1.2, pricePerKg: 23, label: "镭射PET铝" },
  Custom: { density: 1.0, defaultThickness: 50, pricePerKg: 10, label: "自定义" },
} as const;

const PRINT_COVERAGE_OPTIONS = [
  { pct: 0, price: 0.0 },
  { pct: 25, price: 0.11 },
  { pct: 50, price: 0.13 },
  { pct: 100, price: 0.16 },
  { pct: 150, price: 0.21 },
  { pct: 200, price: 0.26 },
  { pct: 300, price: 0.36 }, // 含哑油
] as const;

const LAMINATION_PRICE: Record<LaminationStep["process"], number> = {
  dry: 0.13,
  dry_retort: 0.18,
  solventless: 0.065,
};

// 新增：卷膜分切费 元/㎡
const SLITTING_PRICE = 0.05;


// 吸嘴单价（已含“吸嘴价格+压的工钱”）
const SPOUT_PRICE = {
  "8.2mm": 0.04,
  "8.6mm": 0.056,
  "9.6mm": 0.10,
  "10mm": 0.08,
  "13mm": 0.12,
  "15mm": 0.125,
  "16mm_单卡": 0.145,
  "16mm_双卡": 0.16,
  "20mm": 0.24,
  "22mm": 0.24,
  "26mm": 0.29,
  "33mm": 0.34,
  "40mm": 0.80,
} as const;

const SPOUT_LABEL_MAP: Record<keyof typeof SPOUT_PRICE, string> = {
  "8.2mm": "8.2mm",
  "8.6mm": "8.6mm",
  "9.6mm": "9.6mm",
  "10mm": "10mm",
  "13mm": "13mm",
  "15mm": "15mm",
  "16mm_单卡": "16mm（单卡）",
  "16mm_双卡": "16mm（双卡）",
  "20mm": "20mm",
  "22mm": "22mm",
  "26mm": "26mm",
  "33mm": "33mm",
  "40mm": "40mm",
};

// 统一 calc 入参（老项目可忽略未用字段）
type CalcArgs = {
  areaM2: number;
  widthMm: number;
  bagType: BagType;
  spoutKey?: keyof typeof SPOUT_PRICE | "";
};

// --- 附加工艺定义 ---
type PostProcessKey =
  | "zipper"
  | "ecoZipper"
  | "easyTearZipper"
  | "punchHole"
  | "laserTear"
  | "hotStamp"
  | "wire"
  | "handle"
  | "airValve"
  | "emboss"
  | "windowCut"
  | "spout"
  | "matteOil"; // ✅ 新增：哑油工艺; 

const POST_PROCESS_PRICING: Record<
  PostProcessKey,
  { label: string; desc: string; calc: (args: CalcArgs) => number }
> = {
  zipper: {
    label: "普通拉链",
    desc: "仅适用于自立袋/八边封袋；自立袋：0.10 元/米×袋宽；八边封袋：0.22 元/米×袋宽",
    calc: ({ widthMm, bagType }) => {
      const widthM = widthMm / 1000;
      if (bagType === "standup") return 0.10 * widthM;
      if (bagType === "eightSide") return 0.22 * widthM;
      return 0;
    },
  },

  easyTearZipper: {
    label: "易撕拉链",
    desc: "仅适用于自立袋/八边封袋；自立袋：0.20 元/米×袋宽；八边封袋：0.47 元/米×袋宽",
    calc: ({ widthMm, bagType }) => {
      const widthM = widthMm / 1000;
      if (bagType === "standup") return 0.20 * widthM;
      if (bagType === "eightSide") return 0.47 * widthM;
      return 0;
    },
  },

  ecoZipper: {
    label: "可降解拉链",
    desc: "仅适用于自立袋；自立袋：0.50 元/米×袋宽",
    calc: ({ widthMm, bagType }) => {
      const widthM = widthMm / 1000;
      if (bagType === "standup") return 0.50 * widthM;
      return 0;
    },
  },

  punchHole: {
    label: "冲孔",
    desc: "包含易撕口与挂孔，0元/个（标配免费）",
    calc: () => 0,
  },

  laserTear: {
    label: "激光易撕线",
    desc: "0.2元/米 × 袋宽",
    calc: ({ widthMm }) => 0.2 * (widthMm / 1000),
  },

  hotStamp: {
    label: "烫金",
    desc: "烫金面积×1.2元/㎡ + 0.02元/次",
    calc: ({ areaM2 }) => areaM2 * 1.2 + 0.02,
  },

  wire: {
    label: "加铁丝",
    desc: "铁丝成本=(袋宽+40mm)×0.00013元/mm；贴铁丝人工费：≤140mm=0.024元/个，>140mm=0.026元/个",
    calc: ({ widthMm }) => {
      const wireMaterialCost = (widthMm + 40) * 0.00013; // 元/个

      const laborCost = widthMm <= 140 ? 0.024 : 0.026;

      return wireMaterialCost + laborCost;
    },
  },

  handle: {
    label: "手提",
    desc: "+0.15元/个",
    calc: () => 0.15,
  },

  airValve: {
    label: "透气阀",
    desc: "+0.11元/个",
    calc: () => 0.11,
  },

  emboss: {
    label: "激凸",
    desc: "0.2元/次",
    calc: () => 0.2,
  },


  windowCut: {
    label: "定点开窗",
    desc: "工钱：0.03元/个",
    calc: () => 0.03,
  },

  // ✅ 新增：吸嘴（含吸嘴+压费）
  spout: {
    label: "吸嘴（含吸嘴+压费）",
    desc: "勾选后请选择规格；不同规格单价不同（元/个）",
    calc: ({ spoutKey }) => {
      if (!spoutKey) return 0;                 // 未选规格不计价
      return SPOUT_PRICE[spoutKey] ?? 0;       // 依据规格取价
    },
  },

  // ✅ 新增：哑油工艺（0.15元/㎡ × 展开面积）
  matteOil: {
    label: "哑油工艺",
    desc: "表面哑油处理，按展开面积计价：0.15 元/㎡",
    calc: ({ areaM2 }) => {
      return areaM2 * 0.15;
    },
  },
};

// --- Helpers ---
function mmToM(mm: number) { return mm / 1000; }
function round2(n: number) { return Math.round(n * 100) / 100; }
function round4(n: number) { return Math.round(n * 10000) / 10000; }

function expandWidthMmForSplice(
  bagType: BagType,
  p: { W: number; H: number; BI: number; S: number; BS: number }
): number {
  const { W, H, BI, S, BS } = p;
  switch (bagType) {
    case "taperShape":   return (H + BI) * 2 + 30;      // 自立异形：+0.03m
    case "taperBottom":  return (W + S) * 2 + 20;      // 尖底：+0.02m
    case "flatBottom":   return (W + S) * 2 + 30;      // 方底：+0.03m
    case "standup":      return (H + BI) * 2;          // 自立
    case "eightSide":    return H * 2 + S + 30;        // 八边封：+0.03m
    case "centerSeal":   return (W + S + BS) * 2;      // 中封
    default:             return W * 2;                 // 其他：保守用 W×2
  }
}

// 八边封展开面积拆分：正背底面 + 两个侧面（独立面积）
function eightSideAreaSplit(
  widthMm: number,
  heightMm: number,
  sideExpandMm: number
) {
  const W = mmToM(widthMm); // 袋宽
  const H = mmToM(heightMm); // 袋高
  const S = mmToM(sideExpandMm); // 侧面/底部展开

  // 正背底面面积 = (袋高 + 袋高 + 侧面展开 + 0.03m) × (袋宽 + 0.006m)
  const frontBackBottomArea = (H + H + S + 0.03) * (W + 0.006);
  
  // 两个侧面面积 = (侧面展开 + 0.006m) × 2 × (袋高 + 0.01m)
  const twoSideArea = (S + 0.006) * 2 * (H + 0.01);

  return { 
    frontBackBottomArea, // 正背底面面积
    twoSideArea,         // 两个侧面面积
    totalArea: frontBackBottomArea + twoSideArea // 总面积（兼容原有逻辑）
  };
}

// 放在 helpers 附近
function lossFactorByBag(bagType: BagType): number {
  // 三边封、中封、风琴 => 10%
  if (bagType === "threeSide" || bagType === "centerSeal" || bagType === "gusset") return 1.10;
  // 站立/自立拉链、方底、尖底 => 12%
  if (bagType === "standup" || bagType === "flatBottom" || bagType === "taperBottom") return 1.12;
  // 八边封、三边封异形、自立异形 => 15%
  if (bagType === "eightSide" || bagType === "threeSideShape" || bagType === "taperShape") return 1.15;
  return 1.10; // 兜底
}

// 新增：卷膜核心计算逻辑
interface RollFilmCalcResult {
  perSqmTotalG: number; // 每平方米总克重
  perKgSqm: number; // 每公斤平方数
  layerRatio: Array<{
    label: string;
    ratio: number; // 占比
    weightPerKg: number; // 每公斤该层克重
    cost: number; // 该层成本
  }>;
  materialCostPerKg: number; // 每公斤材料总成本
  processCostPerKg: number; // 每公斤加工成本（印刷+复合+分切）
  totalCostPerKg: number; // 每公斤卷膜总成本
}

function calcRollFilm(
  layers: Layer[],
  printPricePerM2: number,
  laminationPricePerM2: number
): RollFilmCalcResult {
  // 1. 计算每层每平方米克重 & 总成本重
  const layerData = layers.map(layer => {
    const thickness = Number(layer.thicknessUm) || 0;
    const density = Number(layer.density) || 0;
    const price = Number(layer.pricePerKg) || 0;
    const perSqmG = thickness * density; // 厚度(μm) * 密度(g/cm³) = 每平方米克重(g)
    return {
      label: MATERIAL_PRESETS[layer.material].label,
      perSqmG,
      price,
    };
  });

  const perSqmTotalG = layerData.reduce((sum, item) => sum + item.perSqmG, 0);
  // 2. 每公斤平方数 = 1000g / 每平方米总克重
  const perKgSqm = perSqmTotalG > 0.001 ? 1000 / perSqmTotalG : 0;

  // 3. 计算每层占比、每公斤重量、成本
  const layerRatio = layerData.map(item => {
    const ratio = perSqmTotalG > 0 ? item.perSqmG / perSqmTotalG : 0;
    const weightPerKg = ratio * 1000; // 每公斤该层克重
    const cost = (weightPerKg * item.price) / 1000; // 该层成本
    return {
      label: item.label,
      ratio: Number((ratio * 100).toFixed(1)), // 百分比保留1位小数
      weightPerKg: Number(weightPerKg.toFixed(1)),
      cost: Number(cost.toFixed(4)),
    };
  });

  // 4. 每公斤材料总成本
  const materialCostPerKg = layerRatio.reduce((sum, item) => sum + item.cost, 0);

  // 5. 每公斤加工成本 = (印刷+复合+分切) 元/㎡ * 每公斤平方数
  const processCostPerKg = (printPricePerM2 + laminationPricePerM2 + SLITTING_PRICE) * perKgSqm;

  // 6. 每公斤卷膜总成本
  const totalCostPerKg = materialCostPerKg + processCostPerKg;

  return {
    perSqmTotalG: Number(perSqmTotalG.toFixed(1)),
    perKgSqm: Number(perKgSqm.toFixed(2)),
    layerRatio,
    materialCostPerKg: Number(materialCostPerKg.toFixed(4)),
    processCostPerKg: Number(processCostPerKg.toFixed(4)),
    totalCostPerKg: Number(totalCostPerKg.toFixed(4)),
  };
}

function quantityFactor(qty: number, bagType?: BagType): number {
  // 卷膜按公斤计价，数量逻辑可单独调整
  if (bagType === "rollFilm") {
    if (qty >= 1000) return 0.95;
    if (qty >= 500) return 0.98;
    return 1.0;
  }
  // 原有袋子数量逻辑
  if (qty >= 100000) return 0.96;
  if (qty >= 50000) return 0.98;
  if (qty >= 30000) return 1.0;
  if (qty >= 20000) return 1.15;
  if (qty >= 10000) return 1.3;
  return 1.0;
}

// 材料成本（纸类按面积质量法；薄膜按体积密度法）
function materialUnitCostPerBag(
  areaM2: number,
  layer: Layer,
  bagType: BagType,
  widthMm: number,
  heightMm: number,
  bottomInsertMm: number,
  sideExpandMm: number,
  backSealMm: number,
): number {
  const thickness = Number(layer.thicknessUm) || 0;
  const density = Number(layer.density) || 0;
  const price = Number(layer.pricePerKg) || 0;

  // 如果没有拼接，直接用原逻辑
  if (!layer.splice?.enabled) {
    const key = layer.material;
    if (key === "Kraft" || key === "WhiteKraft" || key === "CottonPaper") {
      const kgPerBag = areaM2 * (thickness / 1000);
      return kgPerBag * price;
    }
    return (areaM2 * thickness * density * price) / 1000;
  }

  // ✅ 新拼接开窗逻辑（区分纸类/薄膜类）
  // 1. 计算本层展开总宽（m）
  const totalWidthMm = expandWidthMmForSplice(bagType, {
    W: widthMm, H: heightMm, BI: bottomInsertMm, S: sideExpandMm, BS: backSealMm
  });
  const totalWidthM = totalWidthMm / 1000;

  // 2. 窗口宽度（m，做边界保护）
  const rawWindowMm = Number(layer.splice.windowWidthMm) || 0;
  const windowWidthMm = Math.max(0, Math.min(rawWindowMm, totalWidthMm));
  const windowWidthM = windowWidthMm / 1000;
  const mainWidthM = totalWidthM - windowWidthM;

  // 3. 主材（原层材料）的计算
  const mainKey = layer.material;
  const mainIsPaper = ["Kraft", "WhiteKraft", "CottonPaper"].includes(mainKey);
  const mainThickness = Number(thickness) || (MATERIAL_PRESETS[mainKey].defaultThickness ?? 50);
  const mainPrice = Number(price) || (MATERIAL_PRESETS[mainKey].pricePerKg ?? 10);
  let mainCost = 0;
  if (mainIsPaper) {
    // 纸类公式：宽度(m) × 袋宽(m) × 克重(g) × 单价(元/kg) ÷ 1000
    mainCost = mainWidthM * (widthMm / 1000) * mainThickness * mainPrice / 1000;
  } else {
    // 薄膜公式：宽度(m) × 袋宽(m) × 厚度(um) × 密度(g/cm³) × 单价(元/kg) ÷ 1000
    const mainDensity = Number(density) || (MATERIAL_PRESETS[mainKey].density ?? 1);
    mainCost = mainWidthM * (widthMm / 1000) * mainThickness * mainDensity * mainPrice / 1000;
  }

  // 4. 窗口膜的计算
  const windowKey = layer.splice.windowMaterial;
  const windowIsPaper = ["Kraft", "WhiteKraft", "CottonPaper"].includes(windowKey);
  const windowThickness = Number(layer.splice.windowThicknessUm) || (MATERIAL_PRESETS[windowKey].defaultThickness ?? 50);
  const windowPrice = MATERIAL_PRESETS[windowKey].pricePerKg ?? 10;
  const windowDensity = MATERIAL_PRESETS[windowKey].density ?? 1;
  let windowCost = 0;
  if (windowIsPaper) {
    windowCost = windowWidthM * (widthMm / 1000) * windowThickness * windowPrice / 1000;
  } else {
    windowCost = windowWidthM * (widthMm / 1000) * windowThickness * windowDensity * windowPrice / 1000;
  }

  // 5. 总材料成本 = 主材成本 + 窗口膜成本
  return mainCost + windowCost;
}


function getDefaultLayer(material: MaterialKey): Layer {
  const p = MATERIAL_PRESETS[material];
  return {
    id: Math.random().toString(36).slice(2),
    material,
    thicknessUm: p.defaultThickness ?? 50,
    density: p.density ?? 1.0,
    pricePerKg: p.pricePerKg ?? 10,
  };
}

// --- Main Component ---
export default function BagQuoteCalculator() {
  const [bagType, setBagType] = useState<BagType>("standup");

  // 尺寸（mm）
  const [width, setWidth] = useState<number | "">(190); // 成品袋宽
  const [height, setHeight] = useState<number | "">(300); // 成品袋高
  const [bottomInsert, setBottomInsert] = useState<number | "">(40); // 底部插入
  const [sideExpand, setSideExpand] = useState<number | "">(0); // 风琴等
  const [backSeal, setBackSeal] = useState<number | "">(10); // 中封背封边mm (用于中封/风琴)

  // 新增：卷膜专属状态（宽度mm、长度m，可选）
  const [rollFilmWidth, setRollFilmWidth] = useState<number | "">(190); // 卷膜宽度（mm）
  const [rollFilmLength, setRollFilmLength] = useState<number | "">(1000); // 卷膜总长度（m）

  const [quantity, setQuantity] = useState<number | "">(30000);
  const [rowCountThreeSide, setRowCountThreeSide] = useState(2);
  const [rowCountShape, setRowCountShape] = useState(2);


  const [layers, setLayers] = useState<Layer[]>([
    getDefaultLayer("PET"),
    getDefaultLayer("VMPET"),
    { ...getDefaultLayer("PE"), thicknessUm: 90 },
  ]);

  // 八边封袋材质模式（same = 同材质，diff = 侧边不同）
  const [eightSideMode, setEightSideMode] = useState<"same" | "diff">("same");

  // 八边封袋的侧边层（仅在“diff”模式下启用，多层）
  const [sideLayers, setSideLayers] = useState<Layer[]>([
    {
      id: "side-0",
      material: "PET",
      thicknessUm: 12,
      density: 1.4,
      pricePerKg: 8,
      splice: { 
        enabled: false, 
        windowWidthMm: "", 
        windowMaterial: "PET" as MaterialKey, 
        windowThicknessUm: "" 
      },
    },
  ]);

  // 八边封侧面独立印刷/复合配置（新增）
  const [sidePrintCoveragePct, setSidePrintCoveragePct] = useState(0);
  const [sideLaminations, setSideLaminations] = useState<LaminationStep[]>([
    { id: "Side-L1", process: "solventless" },
  ]);

  const widthNum = Number(width) || 0;
  const heightNum = Number(height) || 0;
  const bottomInsertNum = Number(bottomInsert) || 0;
  const sideExpandNum = Number(sideExpand) || 0;
  const backSealNum = Number(backSeal) || 0;
  const quantityNum = Number(quantity) || 0;
  

  // 复合：默认n-1步，每步可选工艺
  const [laminations, setLaminations] = useState<LaminationStep[]>([
    { id: "L1", process: "dry" },
    { id: "L2", process: "solventless" },
  ]);

  // 在组件状态中新增：
  const [eightSideAreas, setEightSideAreas] = useState({
    frontBackBottomArea: 0,
    twoSideArea: 0
  });

  // 展开面积计算
  const areaM2 = useMemo(() => {
    const W = mmToM(widthNum);
    const H = mmToM(heightNum);
    const BI = mmToM(bottomInsertNum);
    const S = mmToM(sideExpandNum);
    const BS = mmToM(backSealNum);

    switch (bagType) {
      case "standup":
        return W * (H + BI) * 2; // 站立袋：宽 × (高 + 底插入) × 2
      case "threeSide":
        return W * H * 2; // 三边封：宽×高×2
      case "centerSeal":
        return (W + BS) * 2 * H; // 中封：(宽 + 背封边) × 2 × 高
      case "gusset":
        return (W + S + BS) * 2 * H; // 风琴
      case "eightSide": {
        const { frontBackBottomArea, twoSideArea, totalArea } = eightSideAreaSplit(widthNum, heightNum, sideExpandNum);
        // 存储八边封的独立面积
        setEightSideAreas({ frontBackBottomArea, twoSideArea });
        return totalArea; // 总面积
      }
      case "taperBottom": // ｛（袋宽+侧面展开）x2+0.02m｝x（袋高+0.01m）
        return ((W + S) * 2 + 0.02) * (H + 0.01);
      case "flatBottom": // ｛（袋宽+侧面展开）x2+0.03m｝x（袋高+侧面展开/2+0.015m）
        return ((W + S) * 2 + 0.03) * (H + S / 2 + 0.015);
      case "threeSideShape": // 三边封异形袋 = {(袋宽×2+0.01m)} × (袋高+0.005m)
        return (W * 2 + 0.01) * (H + 0.005);
      case "taperShape": // 自立（拉链）异形袋 = {(袋高+底部插入)×2+0.03m} × (袋宽+0.005m)
        return ((H + BI) * 2 + 0.03) * (W + 0.005);
      default:
        return 0;
    }
  }, [bagType, width, height, bottomInsert, sideExpand, backSeal]);

  // 附加工艺
  const [spoutOption, setSpoutOption] = useState<keyof typeof SPOUT_PRICE | "">("");
  const [selectedPost, setSelectedPost] = useState<PostProcessKey[]>([]);
  const postProcessCostPerBag = useMemo(() => {
    return selectedPost.reduce(
      (sum, k) =>
        sum +
        POST_PROCESS_PRICING[k].calc({
          areaM2,
          widthMm: widthNum,
          bagType,
          spoutKey: spoutOption, // ✅ 传入吸嘴规格
        }),
      0
    );
  }, [selectedPost, areaM2, widthNum, bagType, spoutOption]);


  function togglePost(key: PostProcessKey) {
    setSelectedPost(prev =>
      prev.includes(key) ? prev.filter(k => k !== key) : [...prev, key]
    );
  }



  // 印刷（覆盖率映射到元/㎡）
  const [printCoveragePct, setPrintCoveragePct] = useState(300);
  const printPricePerM2 = useMemo(() => {
    const found = PRINT_COVERAGE_OPTIONS.find(o => o.pct === printCoveragePct);
    return found ? found.price : 0;
  }, [printCoveragePct]);

  // 版费：长度×版周×色数×单价（元/cm²）
  const [plateLenCm, setPlateLenCm] = useState<number | "">(86);
  const [plateCircumferenceCm, setPlateCircumferenceCm] = useState<number | "">(19);
  const [numColors, setNumColors] = useState<number | "">(3);
  const [plateUnitYuanPerCm2, setPlateUnitYuanPerCm2] = useState<number | "">(0.11);

  const plateLenCmNum = Number(plateLenCm) || 0;
  const plateCircumferenceCmNum = Number(plateCircumferenceCm) || 0;
  const numColorsNum = Number(numColors) || 0;
  const plateUnitYuanPerCm2Num = Number(plateUnitYuanPerCm2) || 0;

  // 利润率输入状态（默认 10%）
  const [profitRatePct, setProfitRatePct] = useState<number | "">(10);

  // 汇率：美元 → 人民币（默认 7.2）
  const [exchangeRate, setExchangeRate] = useState<number | "">(7.2);
  const exchangeRateNum = Number(exchangeRate) || 0;

  // 报价生成相关状态
  const [showQuoteResult, setShowQuoteResult] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // 监听输入变化，自动隐藏报价结果
  React.useEffect(() => {
    setShowQuoteResult(false);
  }, [
    bagType, width, height, bottomInsert, sideExpand, backSeal,
    rollFilmWidth, rollFilmLength, quantity, rowCountThreeSide, rowCountShape,
    layers, eightSideMode, sideLayers, laminations, spoutOption, selectedPost,
    printCoveragePct, plateLenCm, plateCircumferenceCm, numColors,
    plateUnitYuanPerCm2, profitRatePct, exchangeRate, eightSideAreas
  ]);

  // 成本明细
  const materialCostPerBag = useMemo(() => {
    // ✅ 八边封 & 侧面不同材质：正背底用主层 + 正背底面积；侧面用侧边层 + 侧面面积
    if (bagType === "eightSide" && eightSideMode === "diff") {
      // 正背底面成本：主层材料 × 正背底面面积
      const frontBackBottomCost = layers.reduce(
        (sum, layer) =>
          sum +
          materialUnitCostPerBag(
            eightSideAreas.frontBackBottomArea, // 用正背底面面积
            layer,
            bagType,
            widthNum,
            heightNum,
            bottomInsertNum,
            sideExpandNum,
            backSealNum
          ),
        0
      );

      // 侧面成本：侧边层材料 × 侧面面积
      const sideCost = sideLayers.reduce(
        (sum, layer) =>
          sum +
          materialUnitCostPerBag(
            eightSideAreas.twoSideArea, // 用侧面面积
            layer,
            bagType,
            widthNum,
            heightNum,
            bottomInsertNum,
            sideExpandNum,
            backSealNum
          ),
        0
      );

      return frontBackBottomCost + sideCost;
    }

    // ✅ 其他袋型 / 八边封同材质：直接用总展开面积 areaM2
    return layers.reduce(
      (sum, layer) =>
        sum +
        materialUnitCostPerBag(
          areaM2,
          layer,
          bagType,
          widthNum,
          heightNum,
          bottomInsertNum,
          sideExpandNum,
          backSealNum
        ),
      0
    );
  }, [
    layers,
    sideLayers,
    areaM2,
    eightSideAreas, // 新增依赖：八边封独立面积
    bagType,
    eightSideMode,
    widthNum,
    heightNum,
    bottomInsertNum,
    sideExpandNum,
    backSealNum,
  ]);

  const printingCostPerBag = useMemo(() => {
    if (bagType === "eightSide") {
      // 八边封：正背底印刷 + 侧面印刷 分开计算
      const frontBackPrint = eightSideAreas.frontBackBottomArea * printPricePerM2;
      const sidePrint = eightSideAreas.twoSideArea * (() => {
        const found = PRINT_COVERAGE_OPTIONS.find(o => o.pct === sidePrintCoveragePct);
        return found ? found.price : 0;
      })();
      return frontBackPrint + sidePrint;
    }
    // 其他袋型：总面积 × 印刷单价
    return areaM2 * printPricePerM2;
  }, [bagType, areaM2, printPricePerM2, eightSideAreas, sidePrintCoveragePct]);

  const laminationCostPerBag = useMemo(() => {
    if (bagType === "eightSide") {
      // 八边封：正背底复合 + 侧面复合 分开计算
      const mainLaminationSum = laminations.reduce((s, st) => s + LAMINATION_PRICE[st.process], 0);
      const sideLaminationSum = sideLaminations.reduce((s, st) => s + LAMINATION_PRICE[st.process], 0);
      const frontBackLamination = eightSideAreas.frontBackBottomArea * mainLaminationSum;
      const sideLamination = eightSideAreas.twoSideArea * sideLaminationSum;
      return frontBackLamination + sideLamination;
    }
    // 其他袋型：总面积 × 复合单价之和
    return areaM2 * laminations.reduce((s, st) => s + LAMINATION_PRICE[st.process], 0);
  }, [bagType, areaM2, laminations, eightSideAreas, sideLaminations]);

  // 新增：卷膜复合单价（元/㎡）
  const laminationPricePerM2 = useMemo(() => {
    return laminations.reduce((s, st) => s + LAMINATION_PRICE[st.process], 0);
  }, [laminations]);

  // 新增：卷膜计算结果
  const rollFilmResult = useMemo(() => {
    if (bagType !== "rollFilm") return null;
    return calcRollFilm(layers, printPricePerM2, laminationPricePerM2);
  }, [bagType, layers, printPricePerM2, laminationPricePerM2]);

  const makingCostPerBag = useMemo(() => {
    // 站立袋：固定为 0.09 × 袋宽
    if (bagType === "standup") {
      return 0.09 * mmToM(widthNum);
    }
    // 三边封袋
    if (bagType === "threeSide") {
      const shortSideM = mmToM(Math.min(widthNum, heightNum));
      let costPerBag = 0;
      if (rowCountThreeSide === 1) costPerBag = 0.045 * shortSideM;
      else if (rowCountThreeSide === 2) costPerBag = 0.03 * shortSideM;
      else if (rowCountThreeSide === 3) costPerBag = 0.0225 * shortSideM;
      return costPerBag;
    }
    // 中封/风琴袋
    if (bagType === "centerSeal" || bagType === "gusset") {
      return 0.04 * mmToM(heightNum);
    }
    // 八边封袋
    if (bagType === "eightSide") {
      return 0.28 * mmToM(widthNum);
    }
    // 尖底袋
    if (bagType === "taperBottom") {
      return 0.22 * mmToM(heightNum);
    }
    // 方底袋
    if (bagType === "flatBottom") {
      return 0.25 * mmToM(heightNum);
    }
    // 三边封异形袋
    if (bagType === "threeSideShape") {
      const shortSideM = mmToM(Math.min(widthNum, heightNum));
      let base = 0;
      if (rowCountShape === 1) base = 0.045 * shortSideM;
      else if (rowCountShape === 2) base = 0.03 * shortSideM;
      else if (rowCountShape === 3) base = 0.0225 * shortSideM;
      const dieCutFee =
        rowCountShape === 1 ? 0.018 : rowCountShape === 2 ? 0.009 : 0.006;
      return base + dieCutFee;
    }
    // 自立异形袋
    if (bagType === "taperShape") {
      const base = 0.09 * mmToM(widthNum);
      return base + 0.018; // 模切费
    }
    return 0;
  }, [bagType, widthNum, heightNum, rowCountThreeSide, rowCountShape]);

  const sumPerBagBeforeQty =
    materialCostPerBag +
    printingCostPerBag +
    laminationCostPerBag +
    makingCostPerBag +
    postProcessCostPerBag;

  const qtyFactor = quantityFactor(quantityNum);
  const unitPrice = sumPerBagBeforeQty * qtyFactor; // 袋子单价（不含版费/上机费）

  // 不含损耗/利润的单价与总价
  const unitPriceNoWaste = unitPrice;
  const totalNoWaste = unitPriceNoWaste * quantityNum;

  // 损耗系数 & 含损耗单价/总价
  const lossFactor = useMemo(() => lossFactorByBag(bagType), [bagType]);
  const unitPriceWithWaste = unitPriceNoWaste * lossFactor;
  const totalWithWaste = unitPriceWithWaste * quantityNum;

  // 利润系数 & 报价（含损耗+利润）
  const profitFactor = 1 + ((Number(profitRatePct) || 0) / 100);
  const quotedUnitPrice = unitPriceWithWaste * profitFactor;
  const quotedTotal = quotedUnitPrice * quantityNum;

  const plateFee = useMemo(() => {
    const areaCm2 = plateLenCmNum * plateCircumferenceCmNum;
    return areaCm2 * plateUnitYuanPerCm2Num * numColorsNum;
  }, [plateLenCmNum, plateCircumferenceCmNum, numColorsNum, plateUnitYuanPerCm2Num]);


  // 上机费逻辑：仅当数量 < 10,000 时启用
  const setupFee = quantityNum < 10000 ? Math.min(200 * numColorsNum, 1800) : 0;

  // 三套“含版费”总计
  const grandTotalNoWaste = totalNoWaste + plateFee + setupFee;
  const grandTotalWithWaste = totalWithWaste + plateFee + setupFee;
  const grandTotalQuoted = quotedTotal + plateFee + setupFee;

  // --- UI helpers ---
  function updateLayer(idx: number, patch: Partial<Layer>) {
    setLayers(ls => ls.map((l, i) => (i === idx ? { ...l, ...patch } : l)));
  }
  function addLayer(material: MaterialKey = "Custom") {
    setLayers(ls => {
      const next = [...ls, getDefaultLayer(material)];
      // 自动调整复合步数 = 层数 - 1
      const needed = Math.max(next.length - 1, 0);
      setLaminations(prev => {
        const copy = [...prev];
        while (copy.length < needed) copy.push({ id: Math.random().toString(36).slice(2), process: "dry" });
        while (copy.length > needed) copy.pop();
        return copy;
      });
      return next;
    });
  }
  function removeLayer(idx: number) {
    setLayers(ls => {
      const next = ls.filter((_, i) => i !== idx);
      const needed = Math.max(next.length - 1, 0);
      setLaminations(prev => prev.slice(0, needed));
      return next;
    });
  }

  function updateSideLayer(idx: number, patch: Partial<Layer>) {
  setSideLayers(ls => ls.map((l, i) => (i === idx ? { ...l, ...patch } : l)));
}

  // 新增：添加侧边层时自动调整侧边复合步数
  function addSideLayer(material: MaterialKey = "PET") {
    setSideLayers(ls => {
      const next = [
        ...ls,
        {
          ...getDefaultLayer(material),
          id: `side-${Math.random().toString(36).slice(2)}`,
          splice: { enabled: false, windowWidthMm: 0, windowThicknessUm: 0, windowMaterial: "PET" as MaterialKey },
        },
      ];
      // 自动调整侧边复合步数 = 侧边层数 - 1
      const needed = Math.max(next.length - 1, 1); // 至少保留1步
      setSideLaminations(prev => {
        const copy = [...prev];
        while (copy.length < needed) copy.push({ id: Math.random().toString(36).slice(2), process: "solventless" });
        while (copy.length > needed) copy.pop();
        return copy;
      });
      return next as Layer[];
    });
  }

  // 新增：删除侧边层时调整复合步数
  function removeSideLayer(idx: number) {
    setSideLayers(ls => {
      const next = ls.filter((_, i) => i !== idx);
      const needed = Math.max(next.length - 1, 1); // 至少保留1步
      setSideLaminations(prev => prev.slice(0, needed));
      return next;
    });
  }

  // 八边封侧面复合工艺调整（新增）
  const updateSideLamination = (idx: number, process: LaminationStep["process"]) => {
    setSideLaminations(prev => 
      prev.map((step, i) => i === idx ? { ...step, process } : step)
    );
  };

  const addSideLamination = () => {
    setSideLaminations(prev => [
      ...prev,
      { id: Math.random().toString(36).slice(2), process: "solventless" }
    ]);
  };

  const removeSideLamination = (idx: number) => {
    if (sideLaminations.length <= 1) return;
    setSideLaminations(prev => prev.filter((_, i) => i !== idx));
  };

  // --- 公式字符串（用于“计算明细”展示） ---
  const f4 = (n: number) => round4(n).toFixed(4);
  const f2 = (n: number) => round2(n).toFixed(2);

  const perLayerBreakdown = layers.map(layer => {
    const key = layer.material;
    if (key === "Kraft" || key === "WhiteKraft" || key === "CottonPaper") {
      // 纸类：成本 = 面积 × (gsm/1000) × 单价
      const cost = materialUnitCostPerBag(areaM2, layer, bagType, widthNum, heightNum, bottomInsertNum, sideExpandNum, backSealNum);
      return {
        label: MATERIAL_PRESETS[key].label,
        formula: `面积 ${f4(areaM2)} × (克重 ${layer.thicknessUm}/1000) × 单价 ${layer.pricePerKg} = ${f4(cost)} 元/个`,
        cost,
      };
    }
    const cost = materialUnitCostPerBag(areaM2, layer, bagType, widthNum, heightNum, bottomInsertNum, sideExpandNum, backSealNum);
    return {
      label: MATERIAL_PRESETS[key].label,
      formula: `面积 ${f4(areaM2)} × 厚度 ${layer.thicknessUm}μm × 密度 ${layer.density} × 单价 ${layer.pricePerKg} ÷1000 = ${f4(cost)} 元/个`,
      cost,
    };
  });

  const laminationSumUnit = laminations.reduce((s, st) => s + LAMINATION_PRICE[st.process], 0); // 元/㎡